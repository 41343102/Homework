#41343102

 **問題1**
 
#**遞迴方式**
##問題描述

Ackermann用來測試電腦或演算法的遞迴能力，會根據兩個整數參數 m 和 n 遞迴呼叫自身，直到滿足停止條件為止。

##解題策略

1.每次呼叫根據 m 和 n 的值進行遞迴分支，結束條件是 m == 0

2.使用 遞迴函數 (Recursive Function) 直接實作定義式

3.呼叫遞迴函數計算結果後輸出

##程式實作
```cpp
#include <iostream>
using namespace std;

int Ack(int m, int n)
{
	if (m == 0)
	{
		return n + 1;
	}
	else if (n == 0)
	{
		return Ack(m - 1, 1);
	}
	else
	{
		return Ack(m - 1, Ack(m, n - 1));
	}
}
	int main(){
		int m, n;
		cout << "m: ";
		cin >> m;
		cout << "n: ";
		cin >> n;
		cout << "Ack(" << m << "," << n << ")=" << Ack(m, n) << endl;
		return 0;
	}
```

##效能分析

1.時間複雜度:當 m ≤ 2 時為 $O(n)$（線性成長）
            當 m = 3 時為 $O(2ⁿ)$（指數成長）
            當 m ≥ 4 時則為 超指數級（執行時間極長，實際上無法計算）

2.空間複雜度:當 m ≤ 2 時約為 $O(n)$
            當 m = 3 時為 $O(2ⁿ)$
            當 m ≥ 4 時則為 超指數級，，容易導致stack overflow
            

##測試與驗證
| 測試案例 | 輸入參數 $(m,n)$ | 預期輸出 | 實際輸出 |
|----------|--------------|----------|----------|
| 測試一   | $(1,1)$      | 3        | 3        |
| 測試二   | $(2,2)$      | 7        | 7        |
| 測試三   | $(3,3)$      | 61       | 61       |
| 測試四   | $(4,0)$      | 13       | 13       |

##申論及開發報告

###資料結構：
主要使用 遞迴呼叫堆疊作為資料結構
在每次函數呼叫時，系統自動在堆疊中儲存目前的變數與返回位置
當到達終止條件後，系統會依照堆疊的後進先出原則逐層回傳結果
選擇此結構的原因是 Ackermann 屬於多層遞迴問題，堆疊能有效追蹤每一層的呼叫狀態與變數值

###演算法：
採用 遞迴演算法，直接依照 Ackermann 的數學定義進行實作
遞迴方式簡單、直覺，能清楚呈現函數間的呼叫關係與回傳流程
之所以採用遞迴，是因為此函數本身以遞迴形式定義，使用迴圈難以表達層層嵌套的結構
雖然效率不高且容易造成堆疊溢位，但能充分展示遞迴與堆疊的運作原理


**非遞迴方式**

##問題描述

1.本題的目標是以非遞迴方式實作 Ackermann 函數

2.透過 數學公式化的方式 來模擬遞迴過程

##解題策略

1.依照輸入的 m 值，直接使用對應的數學公式計算結果

2.若 m>3，由於結果成長過快，程式僅提示「m 太大」而不進行實際運算

3.使用 for 迴圈計算 2^(n+3)，以避免使用遞迴或堆疊結構

##程式實作
```cpp
#include <iostream>
using namespace std;

int Ack(int m, int n) {
    if (m == 0) return n + 1;
    else if (m == 1) return n + 2;
    else if (m == 2) return 2 * n + 3;
    else if (m == 3) {
        int result = 1;              
        for (int i = 0; i < n + 3; i++) {
            result *= 2;
        }
        return result - 3;
    }
    else {
        cout << "m 太大，非遞迴版本不支援 m > 3\n";
        return 0;
    }
}

int main() {
    int m, n;
    cout << "m: ";
    cin >> m;
    cout << "n: ";
    cin >> n;

    cout << "Ack(" << m << "," << n << ") = " << Ack(m, n) << "\n";
    return 0;
}
```

##效能分析

1.時間複雜度:當 m <= 2 時為 $O(1)$
            當 m = 3 時為 $O(n)$

2.空間複雜度:當 m <= 3 時為 $O(1)$
            

#測試與驗證
| 測試案例 | 輸入參數 $(m,n)$ | 預期輸出 | 實際輸出 |
|----------|--------------|----------|----------|
| 測試一   | $(1,1)$      | 3        | 3        |
| 測試二   | $(2,2)$      | 7        | 7        |
| 測試三   | $(3,3)$      | 61       | 61       |

##申論及開發報告

資料結構：
屬於數學函式運算型問題，由於非遞迴版本不再使用函式呼叫堆疊（stack）或遞迴記憶體框架，因此在資料結構方面採取最簡化的設計
與遞迴版本相比，遞迴版需要建立大量函式呼叫堆疊（stack frame）
而本非遞迴版僅用變數儲存中間結果，因此能有效避免「堆疊溢位（stack overflow）」問題
演算法：
在演算法部分，程式依據 Ackermann 函數的定義式，將遞迴關係改寫為封閉公式（Closed Form），達成非遞迴實作的目標

#**問題二**

##問題描述

輸出一個集合中所有可能的子集合，包含空集合與集合本身，也就是所有元素的選擇組合

##解題策略

使用 遞迴演算法 依序處理集合中的每個元素，
對每個元素分別考慮「選」與「不選」兩種情況。
當所有元素都被處理後，就能產生出所有可能的子集合

##程式實作
```cpp
#include <iostream>
using namesapce std;

void sub(char set[], int subset[], int Size) {
    cout << "{ ";
    for (int i = 0; i < Size; i++) {
        cout << set[subset[i]] << " ";
    }
    cout << "}" << endl;
}

void powerset(char set[], int n, int subset[], int Size, int index) {
    if (index == n) { 
        sub(set, subset, Size);
        return;
    }

    powerset(set, n, subset, Size, index + 1);

    subset[Size] = index;
    powerset(set, n, subset, Size + 1, index + 1);
}

int main() {
    char set[] = { 'a', 'b', 'c' };
    int n = sizeof(set) / sizeof(set[0]);
    int subset[10];

    cout << "Power set of S = {a, b, c} is:" << endl;
    powerset(set, n, subset, 0, 0);

    return 0;
}
```

##效能分析

1.時間複雜度:對於集合中每個元素，都有「選」或「不選」兩種情況，因此總共有 2ⁿ 個子集合要生成。
每次生成子集合需要 $O(n)$ 時間來輸出內容，所以整體時間複雜度為 $O(n × 2ⁿ)$

2.空間複雜度:在遞迴過程中，最多同時記錄 n 層遞迴狀態與子集合內容，因此空間複雜度為 $O(n)$

##測試與驗證

| 測試案例 | 輸入參數 $S = {}$ | 預期輸出 | 實際輸出 |
|----------|--------------|----------|----------|
| 測試一   | $S = {a, b}$         | {}, {a}, {b}, {a, b}        | {}, {a}, {b}, {a, b}        |
| 測試二   | $S = {a, b, c}$      | {}, {a}, {b}, {c}, {a, b}, {a, c}, {b, c}, {a, b, c}        | {}, {a}, {b}, {c}, {a, b}, {a, c}, {b, c}, {a, b, c}        |
| 測試三   | $S = {}$(空集合)             | {}        | {}        |

##申論及開發報告

資料結構：
使用陣列來儲存集合元素與目前生成的子集合。
陣列能以索引方式快速存取資料，且在遞迴過程中方便記錄每個被選取的元素。
遞迴呼叫時系統自動利用堆疊保存每層函數的狀態，
使程式能逐層探索與回溯所有可能的子集合

演算法：
採用遞迴演算法依序處理集合中的每個元素。
每個元素都有「選取」或「不選取」兩種情況，
當所有元素皆處理完後，即可輸出一組完整的子集合。
此方法能簡潔地對應冪集的數學定義，邏輯清楚、實作容易
