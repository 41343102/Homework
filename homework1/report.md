#41343102
 問題1
 
遞迴方式

#問題描述

Ackermann用來測試電腦或演算法的遞迴能力，會根據兩個整數參數 m 和 n 遞迴呼叫自身，直到滿足停止條件為止。

#解題策略

1.每次呼叫根據 m 和 n 的值進行遞迴分支，結束條件是 m == 0

2.使用 遞迴函數 (Recursive Function) 直接實作定義式

3.呼叫遞迴函數計算結果後輸出

#程式實作
```cpp
#include <iostream>
using namespace std;

int Ack(int m, int n)
{
	if (m == 0)
	{
		return n + 1;
	}
	else if (n == 0)
	{
		return Ack(m - 1, 1);
	}
	else
	{
		return Ack(m - 1, Ack(m, n - 1));
	}
}
	int main(){
		int m, n;
		cout << "m: ";
		cin >> m;
		cout << "n: ";
		cin >> n;
		cout << "Ack(" << m << "," << n << ")=" << Ack(m, n) << endl;
		return 0;
	}
```

#效能分析

1.時間複雜度:當 m ≤ 2 時為 $O(n)$（線性成長）
            當 m = 3 時為 $O(2ⁿ)$（指數成長）
            當 m ≥ 4 時則為 超指數級（執行時間極長，實際上無法計算）

2.空間複雜度:當 m ≤ 2 時約為 $O(n)$
            當 m = 3 時為 $O(2ⁿ)$
            當 m ≥ 4 時則為 超指數級，，容易導致stack overflow
            

#測試與驗證
| 測試案例 | 輸入參數 $(m,n)$ | 預期輸出 | 實際輸出 |
|----------|--------------|----------|----------|
| 測試一   | $(1,1)$      | 3        | 3        |
| 測試二   | $(2,2)$      | 7        | 7        |
| 測試三   | $(3,3)$      | 61       | 61       |
| 測試四   | $(4,0)$      | 13       | 13       |

#申論及開發報告

資料結構：
主要使用 遞迴呼叫堆疊作為資料結構
在每次函數呼叫時，系統自動在堆疊中儲存目前的變數與返回位置
當到達終止條件後，系統會依照堆疊的後進先出原則逐層回傳結果
選擇此結構的原因是 Ackermann 屬於多層遞迴問題，堆疊能有效追蹤每一層的呼叫狀態與變數值

演算法：
採用 遞迴演算法，直接依照 Ackermann 的數學定義進行實作
遞迴方式簡單、直覺，能清楚呈現函數間的呼叫關係與回傳流程
之所以採用遞迴，是因為此函數本身以遞迴形式定義，使用迴圈難以表達層層嵌套的結構
雖然效率不高且容易造成堆疊溢位，但能充分展示遞迴與堆疊的運作原理


非遞迴方式

#問題描述

1.本題的目標是以非遞迴方式實作 Ackermann 函數

2.透過 數學公式化的方式 來模擬遞迴過程

#解題策略

1.依照輸入的 m 值，直接使用對應的數學公式計算結果

2.若 m>3，由於結果成長過快，程式僅提示「m 太大」而不進行實際運算

3.使用 for 迴圈計算 2^(n+3)，以避免使用遞迴或堆疊結構

#程式實作
```cpp
#include <iostream>
using namespace std;

int Ack(int m, int n)
{
	if (m == 0)
	{
		return n + 1;
	}
	else if (n == 0)
	{
		return Ack(m - 1, 1);
	}
	else
	{
		return Ack(m - 1, Ack(m, n - 1));
	}
}
	int main(){
		int m, n;
		cout << "m: ";
		cin >> m;
		cout << "n: ";
		cin >> n;
		cout << "Ack(" << m << "," << n << ")=" << Ack(m, n) << endl;
		return 0;
	}
```

#效能分析

1.時間複雜度:當 m <= 2 時為 $O(1)$
            當 m = 3 時為 $O(n)$

2.空間複雜度:當 m <= 3 時為 $O(1)$
            

#測試與驗證
| 測試案例 | 輸入參數 $(m,n)$ | 預期輸出 | 實際輸出 |
|----------|--------------|----------|----------|
| 測試一   | $(1,1)$      | 3        | 3        |
| 測試二   | $(2,2)$      | 7        | 7        |
| 測試三   | $(3,3)$      | 61       | 61       |

#申論及開發報告

資料結構：
主要使用 遞迴呼叫堆疊作為資料結構
在每次函數呼叫時，系統自動在堆疊中儲存目前的變數與返回位置
當到達終止條件後，系統會依照堆疊的後進先出原則逐層回傳結果
選擇此結構的原因是 Ackermann 屬於多層遞迴問題，堆疊能有效追蹤每一層的呼叫狀態與變數值

演算法：
採用 遞迴演算法，直接依照 Ackermann 的數學定義進行實作
遞迴方式簡單、直覺，能清楚呈現函數間的呼叫關係與回傳流程
之所以採用遞迴，是因為此函數本身以遞迴形式定義，使用迴圈難以表達層層嵌套的結構
雖然效率不高且容易造成堆疊溢位，但能充分展示遞迴與堆疊的運作原理


